---
name: react-best-practices
description: 编写与审查 React 组件时遵循的约定与最佳实践。在编写/修改 React 组件、讨论 React 实现方式、或用户询问 React 写法时使用。
---

# React 最佳实践

## Hooks 规则

- 只在函数组件顶层调用，不在循环、条件或嵌套函数中调用。
- 自定义 Hook 以 `use` 开头，内部只调用其他 Hooks 或内置 Hook。

## 状态与数据流

- **状态放对位置**：只被单一组件用的状态放在该组件；需要共享的再提升到最近公共父组件或用 context/状态库。
- **不可变更新**：用新对象/数组替代原地修改（展开运算、`map`/`filter` 等），避免直接改 `state`。
- **派生状态**：能从 props/state 算出的不单独存 state，在渲染时计算或用 `useMemo`（仅当计算成本高时）。

## 列表与 key

- 列表渲染必须提供稳定、唯一的 `key`（优先用 id，避免用 index 作为唯一 key，尤其列表会增删重排时）。
- `key` 写在列表项最外层元素，不传给子组件当 prop 使用。

## 性能与副作用

- **useEffect 依赖**：依赖项写全，避免 stale closure；若只需「挂载时执行一次」用空依赖 `[]` 并确认无遗漏依赖。
- **useCallback/useMemo**：仅在子组件因引用变化导致不必要重渲染、或计算量明显大时使用，不默认包一层。
- **事件与订阅**：在 `useEffect` 里订阅，在 cleanup 函数里取消订阅，避免泄漏。

## 组件设计

- **单一职责**：组件尽量只做一件事，过大则拆成小组件或抽成自定义 Hook。
- **受控 vs 非受控**：表单等需要即时校验或联动时用受控；简单场景可用非受控 + ref。
- **组合优于配置**：用 `children`、slot 或 render prop 组合 UI，避免过多 props 驱动多种形态。

## 类型与可访问性

- 使用 TypeScript 时为组件 props 定义清晰类型（接口或类型别名）。
- 交互元素保证可访问：语义化标签、必要 `aria-*`、键盘可操作。

## 审查时关注

- 是否有违反 Hooks 规则或依赖项不完整的 `useEffect`。
- 列表是否使用稳定 key、状态是否不可变更新。
- 是否存在可抽取的重复逻辑（自定义 Hook 或工具函数）。
